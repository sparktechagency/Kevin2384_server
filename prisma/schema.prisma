// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client"
  output        = "../generated/prisma"
  moduleFormat  = "cjs"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  avatar         String?
  email          String    @unique
  fullName       String
  phone          String
  password       String
  role           UserRole
  sport          String?
  email_verified Boolean   @default(false)
  is_deleted     Boolean   @default(false)
  is_blocked     Boolean   @default(false)
  fcm_token      String?
  dob            DateTime?

  participated_sessions SessionParticipant[]
  created_sessions      Session[]
  stripe_customer_id    String?

  chat_rooms ChatMember[]

  sent_chats     Chat[]         @relation(name: "sent_chats")
  received_chats Chat[]         @relation(name: "received_chats")
  subscriptions  Subscription[]
  notifications  Notification[]
  payouts        DuePayouts[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model PlatformFee {
  id  String @id @default(auto()) @map("_id") @db.ObjectId
  fee Float  @default(0.0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("platform_fee")
}

model Subscription {
  id                   String             @id @default(auto()) @map("_id") @db.ObjectId
  user_id              String             @db.ObjectId
  stripe_sub_id        String
  status               SubscriptionStatus @default(ACTIVE)
  current_period_start DateTime
  current_period_end   DateTime

  user User @relation(references: [id], fields: [user_id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("subscriptions")
}

model Session {
  id                  String               @id @default(auto()) @map("_id") @db.ObjectId
  banner              String
  coach_id            String               @db.ObjectId
  title               String
  location            Json
  description         String
  additional_notes    String?
  address             String
  participant_min_age Int
  started_at          DateTime
  completed_at        DateTime
  report_till         DateTime?
  report_valid        Boolean              @default(false)
  max_participants    Int
  fee                 Float
  status              SessionStatus        @default(CREATED)
  objectives          String[]
  equipments          String[]
  type                SessionType?
  coach               User                 @relation(references: [id], fields: [coach_id], onDelete: Cascade)
  participants        SessionParticipant[]
  payments            Payment[]
  refund_requests     RefundRequest[]
  payout              DuePayouts?
  reports             Report[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}

// model SessionTemplate{
//   id                  String        @id @default(auto()) @map("_id") @db.ObjectId
//   banner              String
//   coach_id            String        @db.ObjectId
//   title               String
//   location            Json
//   description         String
//   additional_notes    String?
//   address             String
//   participant_min_age Int
//   started_at          DateTime
//   objectives          String[]
//   equipments          String[]
//   completed_at        DateTime
//   max_participants    Int
//   fee                 Float
//   recurringData     RecurringData?
//   type                SessionType? 
//   coach             User   @relation(references: [id], fields: [coach_id])

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   @@map("templates")
// }

// model RecurringData {
//   id              String  @id  @default(auto())  @map("_id")  @db.ObjectId
//   template_id      String  @db.ObjectId @unique
//   recurrence_rule String
//   started_at       DateTime
//   latest_published    DateTime
//   next_published     DateTime?
//   ended_at        DateTime
//   status          RecurringStatus @default(ACTIVE)
//   template        SessionTemplate  @relation(references: [id], fields: [template_id])

//   createdAt   DateTime @default(now())
//   updatedAt   DateTime  @updatedAt

//   @@map("recurring_data")
// }

model SessionParticipant {
  id             String                   @id @default(auto()) @map("_id") @db.ObjectId
  player_id      String                   @db.ObjectId
  session_id     String                   @db.ObjectId
  payment_status ParticipantPaymentStatus @default(Pending)
  payment_method PaymentMethod
  player_status  PlayerStatus             @default(Pending)

  session        Session        @relation(references: [id], fields: [session_id], onDelete: Cascade)
  player         User           @relation(references: [id], fields: [player_id], onDelete: Cascade)
  refund_request RefundRequest?
  payments       Payment[]
  reports        Report[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("session_participants")
}

model Payment {
  id           String        @id @default(auto()) @map("_id") @db.ObjectId
  item_id      String?       @db.ObjectId
  buyer_id     String?       @db.ObjectId
  status       PaymentStatus @default(Pending)
  payment_type PaymentType
  platform_fee Float
  session_fee  Float
  total_amount Float

  stripe_session_id  String?
  stripe_intent_id   String?
  stripe_charge_id   String?
  stripe_customer_id String?

  item        Session?            @relation(references: [id], fields: [item_id], onDelete: SetNull)
  participant SessionParticipant? @relation(references: [id], fields: [buyer_id], onDelete: SetNull)
  refund      RefundRequest?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payments")
}

model RefundRequest {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  participant_id      String              @unique @db.ObjectId
  session_id          String              @db.ObjectId
  payment_id          String              @unique @db.ObjectId
  status              RefundRequestStatus @default(Pending)
  refund_request_type RefundRequestType
  accepted_by         String?             @db.ObjectId
  rejection_note      String?
  refunded_amount     Float

  reason String

  participant SessionParticipant @relation(references: [id], fields: [participant_id])
  session     Session            @relation(references: [id], fields: [session_id])
  payment     Payment            @relation(references: [id], fields: [payment_id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("refund_requests")
}

model Report {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  session_id     String       @db.ObjectId
  participant_id String       @db.ObjectId
  description    String
  need_refund    Boolean      @default(false)
  status         ReportStatus @default(Pending)
  replied_by     String?      @db.ObjectId
  reply          String?

  session     Session            @relation(references: [id], fields: [session_id])
  participant SessionParticipant @relation(references: [id], fields: [participant_id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("reports")
}

model SessionCancelRequest {
  id             String                     @id @default(auto()) @map("_id") @db.ObjectId
  reason         String
  session_id     String                     @db.ObjectId
  participant_id String                     @db.ObjectId
  sataus         SessionCancelRequestStatus @default(Pending)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("cancel_requests")
}

model Otp {
  id         String    @id @default(auto()) @map("_id") @db.ObjectId
  code       Int
  for        OtpFor
  email      String
  expires_in DateTime
  otp_status OtpStatus @default(CREATED)
  data       Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("otps")
}

model ChatRoom {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  members ChatMember[]

  chats Chat[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("chat_rooms")
}

model ChatMember {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  chatRoom_id String @db.ObjectId
  user_id     String @db.ObjectId

  chatRoom ChatRoom @relation(references: [id], fields: [chatRoom_id], onDelete: Cascade)
  user     User     @relation(references: [id], fields: [user_id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("chat_members")
}

model Chat {
  id           String      @id @default(auto()) @map("_id") @db.ObjectId
  chatRoom_id  String      @db.ObjectId
  sender_id    String      @db.ObjectId
  receiver_id  String      @db.ObjectId
  message      String
  file         Bytes?
  type         MessageType @default(TEXT)
  is_read      Boolean     @default(false)
  is_delivered Boolean     @default(false)

  chatRoom ChatRoom @relation(references: [id], fields: [chatRoom_id], onDelete: Cascade)
  sender   User     @relation(name: "sent_chats", references: [id], fields: [sender_id], onDelete: Cascade)
  receiver User     @relation(name: "received_chats", references: [id], fields: [receiver_id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("chats")
}

model Notification {
  id       String            @id @default(auto()) @map("_id") @db.ObjectId
  user_id  String            @db.ObjectId
  title    String
  message  String
  is_read  Boolean           @default(false)
  level    NotificationLevel @default(INFO)
  audience Audience          @default(USER)
  user     User              @relation(references: [id], fields: [user_id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("notifications")
}

model DuePayouts {
  id            String @id @default(auto()) @map("_id") @db.ObjectId
  session_id    String @unique @db.ObjectId
  coach_id      String @db.ObjectId
  total_amount  Float
  refund_amount Float  @default(0.0)

  status  PayoutStatus @default(Pending)
  session Session      @relation(references: [id], fields: [session_id])
  coach   User         @relation(references: [id], fields: [coach_id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("due_payouts")
}

model SitePolicy {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  type PolicyType

  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("site_policy")
}

enum ReportStatus {
  Pending
  Replied
}

enum RecurringStatus {
  ACTIVE
  CANCELLED
}

enum RefundRequestType {
  AdminApproval
  AutoAccepted
}

enum SessionType {
  Free
  Paid
}

enum PolicyType {
  PrivacyPolicy
  Terms
}

enum PayoutStatus {
  Pending
  Hold
  Paid
  Cancelled
}

enum PaymentType {
  Subscription
  Enrollment
  Refund
}

enum PaymentStatus {
  Pending
  Succeeded
  Cancelled
  Failed
  Refunded
}

enum NotificationLevel {
  INFO
  WARNING
  CRITICAL
}

enum Audience {
  USER
  ADMIN
}

enum UserRole {
  COACH
  PLAYER
  ADMIN
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  CANCELED
  PAST_DUE
  TRIALING
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  FILE
}

type Coards {
  lat  Float
  long Float
}

enum RefundRequestStatus {
  Pending
  Completed
  Cancelled
  Accepted
  Paid
}

enum SessionCancelRequestStatus {
  Pending
  Accepted
  Cancelled
}

enum SessionStatus {
  CREATED
  ONGOING
  COMPLETED
  CANCELLED
}

enum OtpStatus {
  CREATED
  VERIFIED
  INVALID
}

enum ParticipantPaymentStatus {
  Cash
  Paid
  Pending
  Refunded
  Failed
}

enum PaymentMethod {
  ONLINE
  CASH
}

enum PlayerStatus {
  Pending
  Attending
  Cancelled
}

enum OtpFor {
  Forget_Password
  Email_Verification
  Change_Email
}
